; #############################################################################
; # Atlas 2 Kernel - String routines                                          #
; # Created: 28.01.2013                                                       #
; # Changelog:                                                                #
; # 28.01.2013, plusmid - file created, basic routines                        #
; # 31.01.2013, plusmid - added strncpy, strpack, strunpack, pstrlen, ustrlen #
; # 02.02.2013, plusmid - strlen optimized, strncpy fixed, strpack/unpack is  #
; #                       broken                                              #
; # 02.02.2013, bungao - strpack/strunpack fixed and tested                   #
; # 03.02.2013, VladVP - added strcpyfast which is merely an optimization of  #
; #                      strcpy, and optimized strpack and strunpack          #
; #############################################################################


; strlen - calculates the length of a string
; A -> pointer to the string
; A <- length of the string in words
:strlen
	SET PUSH, A

	SUB A, 1

:strlen_loop
	ADD A, 1
	IFN [A], 0
		SET PC, strlen_loop

	SUB A, POP
	SET PC, POP


; strcpy - copies a string from one address to another
; A -> source pointer
; B -> destination pointer
; A <- copied words
:strcpy
	SET PUSH, B
	SET PUSH, C

:strcpy_loop
	IFE [A], 0
		SET PC, strcpy_end
	SET [B], [A]
	ADD A, 1
	ADD B, 1
	SUB C, 1
	IFN C, 0
		SET PC, strcpy_loop

:strcpy_end
	SET [B], [A]
	SET A, C

	SET B, POP
	SET C, POP
	SET PC, POP

	
; strcpyfast - copies a string from one address to another
; MUCH faster than the above function, but uses the I and J
; registers for I/O
; I -> source pointer
; J -> destination pointer
; I <- copied words
:strcpyfast
	SET PUSH, I
	SET PUSH, J

	STI [J], [I]
	IFN [I], 0
	SUB PC, 3 ; using SUB PC instead of SET PC eliminates a (1) clock cycle
			  ; plus, we won't have to use those ugly labels ;)
	
	STI [J], [I] ; why not? :P
	
	SET J, POP
	SUB I, POP
	SET PC, POP

	
; strncpy - same as strcpy but with length limitation
; A -> source string
; B -> destination string
; C -> max length
:strncpy
	SET PUSH, A
	SET PUSH, B
	SET PUSH, C

:strncpy_loop
	SET [B], [A]
	IFE [A], 0
		SET PC, strncpy_end
	SUB C, 1
	ADD A, 1
	ADD B, 1
	IFN C, 0
		SET PC, strncpy_loop

:strncpy_end
	SET C, POP
	SET B, POP
	SET A, POP
	SET PC, POP


; strpack - packs a string
; A -> source string
; B -> destination of the packed string
:strpack
	SET PUSH, A
	SET PUSH, B
	
	SET [B], [A]
	SHL [B], 8
	IFE [A], 0
	ADD PC, 7
	ADD A, 1
	IFE [A], 0
	ADD PC, 4
	BOR [B], [A]
	ADD A, 1
	ADD B, 1
	SUB PC, 0xB
	
	SET B, POP
	SET A, POP
	SET PC, POP

; strunpack - unpacks a string packed by strpack and/or strpackfast
; A -> packed source string
; B -> destination string
:strunpack
	SET PUSH, A
	SET PUSH, B
	SUB B, 1
	
	ADD B, 1
	SET [B], [A]
	SHR [B], 8
	IFE [B], 0
	ADD PC, 7
	ADD B, 1
	SET [B], [A]
	ADD A, 1
	AND [B], 0x00FF
	IFN [B], 0
	SUB PC, 0xC
	
	SET B, POP
	SET A, POP
	SET PC, POP

	
; pstrlen - calculates the length of a string (packed)
; A -> string
; B <- packed length
; ToDo: TEST!
:pstrlen
	JSR strlen
	ADD A, 2 ; +1 for the tailing 0x00 +1 for the packed tailing 0x0000
	SHR A, 1
	SET PC, POP


; ustrlen - calculates the length of a packed string (unpacked)
; A -> string
; A <- length
; ToDo: TEST!
:ustrlen
	SET PUSH, B
	SET PUSH, C

	SET C, 0

:ustrlen_loop
	SET B, [A] ; add 2 to C while the upper byte of [A]!=0x00
	AND B, 0xFF00
	ADD A, 1
	ADD C, 2
	IFN B, 0x0000
		SET PC, ustrlen_loop

	SUB A, 1 ; subtract the number of 0x00 we have counted
	SUB C, 1
	IFE [A], 0x0000
		SUB C, 1

	SET A, C

	SET C, POP
	SET B, POP
	SET PC, POP
